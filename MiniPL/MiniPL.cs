namespace MiniPL
{
    /* Main class which combines all the components of the MiniPL Interpreter, specifically
     * the parser, the semantic analyzer, and the interpreter. It creates the parse tree
     * (based on the tokens generated by the scanner inside the parser), does a semantic 
     * check and interprets it. The error handling is done here as well.
     */
    internal class MiniPL
    {
        private readonly Parser Parser;
        private readonly SemanticAnalyzer Analyzer;
        private readonly Interpreter Interpreter;

        public MiniPL(string filename, bool debugMode = false)
        { 
            Parser = new Parser(filename, debugMode);
            Analyzer = new SemanticAnalyzer(Parser.Ast);
            Interpreter = new Interpreter(Parser.Ast);
        }
        public void Run()
        {
            try
            {
                Parser.Parse();
                Analyzer.Analyze();
                Interpreter.Interpret();
                Context.GetInstance().ClearTable();
            }
            // Panic mode recovery (for scanner and interpreter)
            catch (MiniPLException e)
            {
                PrintError(e);
            }
            // Statement mode recovery (for parser and analyzer)
            catch (ErrorList e)
            {
                foreach (var error in e.Errors)
                {
                    PrintError(error);
                }
            }
            // Non-MiniPL error caused by some bug (hope it won't happen)
            catch (Exception e)
            {
                Console.WriteLine("Interpreter ran into an unexpected error:");
                Console.WriteLine(e.Message);
            }
        }
        /* Print the error in the console, which includes the error type, message passed,
         * and the position of erroreous token in the source code
         */
        private void PrintError(MiniPLException e)
        {
            Console.BackgroundColor = ConsoleColor.DarkRed;
            Console.Write(e.Message);
            Console.ResetColor();
            if (e is FileNotFoundError) return;

            if (Parser.Scanner.File != null)
            {
                Console.WriteLine();
                string line = Parser.Scanner.File.Split('\n')[e.Pos.line - 1];
                int indent = 0;
                foreach (var ch in line)
                {
                    if (ch == '\t' || ch == ' ')
                    {
                        indent++;
                        line = line[1..];
                    }
                    else break;
                }
                Console.WriteLine(line);
                Console.WriteLine($"{new string(' ', e.Pos.column - indent - 1)}^");
            }
        }
    }
}
