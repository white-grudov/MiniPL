namespace MiniPL
{
    // Abstract class for errors generated by MiniPL interpreter
    public abstract class MiniPLException : Exception
    {
        public Position Pos { get; protected set; }
        public MiniPLException(string message) : base(message) { }
    }
    // Lexical error class generated by scanner
    public class LexicalError : MiniPLException
    {
        public const string type = "LexicalError";
        public LexicalError(string message, Position pos) : base(ExMessage.Form(type, message, pos))
        {
            Pos = pos;
        }
    }
    // Syntax error class generated by parser
    public class SyntaxError : MiniPLException
    {
        public const string type = "SyntaxError";
        public SyntaxError(string message, Position pos) : base(ExMessage.Form(type, message, pos))
        {
            Pos = pos;
        }
    }
    // Semantic error class generated by semantic analyzer
    public class SemanticError : MiniPLException
    {
        public const string type = "SemanticError";
        public SemanticError(string message, Position pos) : base(ExMessage.Form(type, message, pos))
        {
            Pos = pos;
        }
    }
    // Runtime error class generated by interpreter
    public class RuntimeError : MiniPLException
    {
        public const string type = "RuntimeError";
        public RuntimeError(string message, Position pos) : base(ExMessage.Form(type, message, pos))
        {
            Pos = pos;
        }
    }
    // File not found error if the path to the source code is invalid
    public class FileNotFoundError : MiniPLException
    {
        public FileNotFoundError(string path) : base($"File {path} does not exist") { }
    }
    // Error list class for statement mode recovery
    public class ErrorList : Exception
    {
        public List<MiniPLException> Errors { get; private set; }
        public ErrorList(List<MiniPLException> errors)
        {
            Errors = errors;
        }
    }
}
